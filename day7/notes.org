* 02 constructed function
一个类中如果没有定义过构造函数，该类会有一个默认的空参数构造函数，如果
在类中定义了指定的构造函数，那么类中默认的构造函数就没有了。

* 03 constructed function
一般函数和构造函数的区别：
1. 构造函数：对象创建时，就会调用与之对应的构造函数，对对象进行初始化。
   一般函数：对象创建后，需要函数功能时才调用。
2. 构造函数：对象创建时，会调用且只调用一次。 一般函数：对象创建后，可
   以调用多次。

* 04 constructed function
什么时候定义构造函数： 描述事物时，该事物一存在就具备的一些内容，这些
内容都定义在构造函数中。

* 05 constructed function 
构造函数运行简单顺序：
1. 堆上面开辟内存，所有成员变量默认初始化。
2. 调用构造函数，在栈内存上面开辟构造函数局部变量。
3. 把栈内存上面的局部变量的数值赋值给堆内存上面的成员变量。
4. 栈内存出栈，把堆内存里面的内存地址赋值给对象，结束对象的创建。

* 06 constructed function return
构造函数中可以使用 return，但是注意因为没有返回值，所以 return不能返回
数值，只能 return。

* 07 constructed function this
当成员变量和局部变量重名，可以用关键字 this 来区分。
this: 代表对象。代表当前对象。this 就是所在函数所属对象的引用。简单说：
哪个对象调用了 this 所在的函数，this 就代表哪个对象。

在类中如果使用成员变量，最好用this指明，这样阅读性会好很多。

* 08 constructed function this
如果在构造函数中调用另外一个构造函数，可以用 this(name) 这样的方法来调
用。但是要注意：只能定义在构造函数的第一行，因为初始化动作要先执行。防
止被这个 this 调用的构造函数覆盖掉其他的赋值操作。

* 09 static member
static 关键字用来修饰成员变量和成员函数，修饰后的成员有以下特点：
1. static 修饰的成员优先于对象的存在，因为随着类的加载而存在
2. static 修饰的数据是共享数据，对象中存储的是特有数据
3. 被所有对象所共享
4. 可以直接被类名调用，也可以用对象名调用

使用时候注意：
1. 静态方法只能访问静态成员
2. 静态方法不可以写 this, super 关键字
3. 主函数是静态的

* 12 static member
成员变量和静态变量的区别：
1. 生命周期不同。成员变量随着对象的创建而存在，随着对象的被回收而释放。
   静态变量随着类的加载而存在，随着类的消失而消失。
2. 调用方式不同。成员变量只能被对象调用。静态变量成为类变量。
3. 别名不同。成员变量也成为实例变量。静态变量成为类变量。
4. 数据存储位置不同。成员变量数据存储在堆内存的对象中，所以也叫对象的
   特有数据。静态变量数据存储在方法区（共享数据区）的静态区，所以也叫
   对象的共享数据。

* 13 static
1. 静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）
2. 静态方法中不可以使用 this 或者 super 关键字。
3. 主函数是静态的。如果主函数需要调用本类中的非静态函数，那么可以使用
   匿名，比如说直接 new Car().show()

* 14 main
public static void main(String[] args)
主函数特殊之处：
1. 格式是固定的。
2. 被 jvm 所识别和调用

public 因为权限是最大的。
static 不需要对象的，直接用主函数所属类名调用即可
void 主函数没有返回值
main 函数名，只是一个被 jvm 识别的固定的名字
String[] args 这是主函数的参数列表，是一个数组类型的参数，而且元素都是
字符串类型

* 15 memory
简单的说，RAM里面分为栈内存和堆内存，ROM分为非静态方法区和静态方法区。
当程序开始运行的时候，首先是 main 所在的类中的静态方法也就是 main 函数
加载到了静态方法区，同时其他静态成员变量也会加载。然后开始运行 main 函
数，这时候栈内存会加载 main 中的变量。
如果 main 当中运行另外一个类的对象，那么首先 静态方法区有类的静态方法
和静态成员变量，非静态方法有非静态的方法和变量。当创建类的对象的时候，
首先在堆内存上面开辟对象的空间，并且进行默认或者显式初始化，然后调用类
的构造函数，在栈内存中进行构造函数的赋值，在出栈后，把堆内存的地址赋值
给创建的对象。

非静态成员函数是共享非静态方法区，但是非静态成员变量是独享堆内存的。

* 16 static
静态什么时候用：
1. 静态变量：当分析对象中所具备的成员变量的数值是相同的，这时这个成员
   就可以被静态修饰。只要数据在对象中是不同的，就是对象的特有数据，必
   须存储在对象中，是非静态的。如果是相同的数据，对象不需要做修改，只
   需要使用即可，不需要存储在对象中，定义成静态的。
2. 静态函数：函数是否用静态修饰，就参考一点，就是该函数功能是否有访问
   到对象中的特有数据。简单点说，从源代码看，该功能是否需要访问到非静
   态的成员变量，如果需要，该功能是非静态的。如果不需要，就可以把该功
   能定义成静态的。当然，也可以定义成非静态。但是非静态需要被对象调用，
   而仅仅创建对象调用非静态的但是没有访问特有数据的方法，该对象的创建
   是没有意义的。

* 17 static
静态代码块：随着类的加载而执行，而且只执行一次，用于给类进行初始化。

先执行静态成员变量初始化，再执行静态代码块。

如果 main 所在的类也有静态代码块，那么这个静态代码块也在 main 之前被执
行。

静态代码块的格式类似： static {}

* 18 class
构造代码块，可以给所有对象进行初始化，而构造函数，只能给对象进行对应的
初始化。

构造代码块格式类似： {}，和静态代码块的区别就是没有 static。

构造代码块只有对象创建的时候才会执行，先执行非静态成员变量初始化，然后
构造代码块，然后构造函数。

局部代码块的作用是限制局部变量的生命周期。

执行的先后：静态代码块，构造代码块，构造函数。
