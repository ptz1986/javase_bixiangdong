* 02 array tool
如果一个类是单纯的工具类，没有自己的非静态成员变量，那么那种类里面的成
员函数应该都是静态成员函数，这种类不应该被用来创建对象，为了防止被创建
对象，只需要手动添加： private ArrayTool(){}，这样私有化构造函数，就不
能被其他函数拿来创建对象了。

如果是多 java 文件源代码，只需要 javac 那个有 main 的源代码，其他源文
件 java 会自己去寻找。

* 03 javadoc
javadoc 用于自动生成注释文件，只能输出 /** */ 之间包含的注释。有
@param @return @author @version 等关键字，注释好了之后，用命令进行生成。

javadoc -d help -author -version ArrayTool.java
-d 后面是文件放置的文件夹
-author -version 这两个属性也进行生成

* 04 single
单例设计模式：可以保证一个类在内存中对象的唯一性。当多个程序使用同一个
配置信息对象时，就必须保证该对象的唯一性。

如何保证：
1. 不允许其他程序使用 new 创建该类对象
2. 在该类创建一个本类的实例
3. 对外提供一个方法让其他程序可以获取该对象

步骤：
1. 私有化该类构造函数
2. 通过 new 在本类中创建一个本类对象
3. 定义一个公有的方法，将创建的对象返回。

        private static Single s = new Single();

        private Single() {}

        public static Single getInstance()
        {
                return s;
        }

* 06 single
延迟加载模式，类加载进来，没有对象，只有调用了 getInstance 方法时，才会创建对象。

class Single {
        private static Single s = null;
        private Single(){}

        public static Single getInstance()
        {
                if (s == null)
                        s = new Single();

                return s;
        }
}

这种方式，也叫做懒汉式，效率会高一点，但是多线程的时候，不能保证唯一性，
所以正常开发的时候不用这种方式，而是用上面那种饿汉式。

* 07 inherit
继承的好处：
1. 提高了代码的复用性
2. 让类与类之间产生了关系，给第三个特征多态提供了前提。

* 08 inherbit
java 中支持单继承，不直接支持多继承，但对 C++ 中的多继承机制进行改良。
单继承： 一个子类只能有一个直接父类
多继承： 一个子类可以有多个直接父类。java 不直接支持多继承，因为多个父
类中有相同成员的时候，会产生调用不确定性，在 java 中是通过“多实现”的
方式来体现。

java 支持多层继承，C 继承 B，B 继承 A，就会出现继承体系。
当要使用一个继承体系时，
1. 查看该体系中的顶层类，了解该体系的基本功能。
2. 创建体系中的最子类对象，完成功能的使用。

* 09 inherbit
什么时候定义继承呢？
当类与类之间存在着所属关系的时候，就定义继承。 xxx 是 yyy 中的一种。
xxx extends yyy. 
所属关系： is a 关系。

* 10 inherbit
在子父类中，成员的特点体现：
1. 成员变量
2. 成员函数
3. 构造函数

当本类的成员和局部变量同名用 this 区分。
当子父类中的成员变量同名用 super 来区分父类。
this 和 super 的用法很相似。
this： 代表一个本类对象的引用。
super: 代表一个父类空间。

* 11 inherbit
子类不能直接访问父类中 private 的成员，只能通过父类的 public 函数来间
接访问。

* 12 inherbit
当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象，称为
覆盖操作。这时函数在子父类中的特性。
函数两个特性：
1. 重载。 同一个类中 overload
2. 覆盖。 子类中，覆盖也成为重写，覆写。 override

覆盖注意事项：
1. 子类方法覆盖父类时，子类权限必须大于等于父类的权限。 private < 默认
   < public.
2. 静态只能覆盖静态，或被静态覆盖。

* 13 inherbit
什么时候使用覆盖操作
当一个类中进行子类的扩展时，子类需要保留父类的功能说明，但是要定义子类
中该功能的特有内容时，就使用覆盖操作完成。
