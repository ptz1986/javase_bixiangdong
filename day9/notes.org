* 01 inherbit function
子父类中的构造函数的特点。在子类构造对象时，发现，访问子类构造函数时，
父类也运行了。原因是：在子类的构造函数中第一行有一个默认的隐式语句：
super();
子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造
函数。

* 02 inherbit init
为什么子类实例化的时候要访问父类中的构造函数呢？ 因为子类继承了父类，
获取了父类中的内容，所以在使用父类内容之前，要先看父类是如何对自己的内
容进行初始化的。
所以子类在构造对象时，必须访问父类中的构造函数。为了完成这个必须的动作，
就在子类的构造函数中加入了 super() 语句。
如果父亲中没有定义空参数构造函数，那么子类的构造函数必须使用 super 明
确要调用父类中哪个构造函数。同时子类和构造函数中如果使用了 this 调用了
本类构造函数时，那么 super 就没有了，因为 super 和 this 就只能放在第一
行，并且只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问
父类的构造函数。

注意： super 语句必须放在子类构造函数的第一行，因为父类的初始化动作要
先完成。

* 03 inherbit init
一个对象实例化过程： Person p = new Person();
1. JVM 会读取指定的路径下的 Person.class 文件，并加载进内存，并会先加
   载 Person 的父类(如果有直接的父类的情况下）。
2. 在堆内存中的开辟空间，分配地址。
3. 并在对象空间中，对对象中的属性进行默认初始化。
4. 调用对应的构造函数进行初始化。
5. 在构造函数中，第一行会先到调用父类中构造函数进行初始化。
6. 父类初始化完毕后，在对子类的属性进行显式初始化。
7. 再进行子类构造函数的特定初始化。
8. 初始化完毕后，将地址值复制给引用变量。

具体例子见 day9/03

* 04 final
final 关键字：
1. final 修饰符，可以修饰 类，方法，变量。
2. final 修饰的类不可以被继承。
3. final 修饰的方法不可以被覆盖。
4. final 修饰的变量是一个常量，只能赋值一次，用于显式初始化。如果在程
   序中一个数据是固定的，那么为了便于阅读，就可以用 final 来修饰这个常
   量。常量所有字母都大些，多个单词，中间用 _ 链接。

* 06 abstract
抽象特点：
1. 方法只有声明没有实现时，该方法为抽象方法，需要被 abstract 修饰。抽
   象方法必须定义在抽象类中。该类也必须被 abstract 修饰。
2. 抽象类不可以被实例化。因为调用抽象方法没有意义。
3. 抽象类必须有子类覆盖了所有的抽象方法后，该子类才可以实例化，否则，
   这个子类还是抽象类。

* 07 abstract
抽象类：
1. 抽象类中有构造函数，可以被子类对象进行初始化。
2. 抽象类可以不定义抽象方法，但是少见，目的就是不让该类创建对象。AWT
   的适配器对象就是这种类。通常这个类中的方法有方法体，但是却没有内容。
   abstract class Demo {
   	void show1(){}
   	void show2(){}
   }
3. 抽象关键字不可以和 private, static, final 共存。
4. 抽象类和一般类的相同点：抽象类和一般类都是用来描述事物的，都在内部
   定义了成员。不同点：一般类有足够的信息描述事物。抽象类描述事物的信
   息可能不足。一般类中不能定义抽象方法，只能定义非抽象方法。抽象类中
   可以定义抽象方法，同时也可以定义非抽象方法。一般类可以被实例化，抽
   象类不可以被实例化。
5. 抽象类一定是个父类。

* 09 interface
当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义
和表示，就是接口 interface.
对于接口当中常见的成员：而且这些成员都有固定的修饰符。
1. 全局变量： public static final
2. 抽象方法： public abstract

因此，接口中的成员是公共的权限。

* 10 interface 
类与类之间是继承关系，类与接口之间是实现关系。
接口不可以实例化，只能由实现了接口的子类并且覆盖了接口中所有的抽象方法
后，该子类才可以实例化，否则这个子类就是一个抽象类。

使用 implements 这个关键字进行实现

* 11 interface
在 java 中不直接支持多继承，因为可以出现相同的函数名造成的调用不确定性。
所以 java 将多继承机制进行改良，在 java 中变成了多实现。一个类可以实现
多个接口。

* 12 interface
接口的出现避免了单继承的局限性，接口与接口之间是继承关系，而且接口可以
多继承。

interface CC {}
interface MM {}
interface QQ extends CC MM {}
class WW implements QQ {};

* 14 abstract interface
抽象类和接口的相同点： 都是不断向上抽取而来的。
抽象类和接口的不同点：
1. 抽象类需要被继承，而且只能单继承。接口需要被实现，而且可以多实现。
2. 抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽
   象方法。接口中只能定义抽象方法，必须有子类去实现。
3. 抽象类的继承是 is a 关系，在定义该体系的基本共性内容。接口的实现是
   like a 关系，在定义体系额外功能。


